#include "main.h"

#include <stdio.h>
#include <stdlib.h>

#include "gba.h"
/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
// #include "images/garbage.h"
#include "images/blank.h"
#include "images/coral.h"
#include "images/fish.h"
#include "images/lostscreen.h"
#include "images/shark.h"
#include "images/turtle.h"
#include "images/underwater.h"
#include "images/wonscreen.h"

/* TODO: */
// Add any additional states you need for your app. You are not requried to use
// these specific provided states.
enum gba_state {
  START,
  PLAY,
  WIN,
  LOSE,
};

void delay (int n) {
  volatile int x = 0;
  for (int i = 0; i < n * 8000; i++) {
    x++;
  }
}

int main(void) {
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3. //
  REG_DISPCNT = MODE3 | BG2_ENABLE;

  // Save current and previous state of button input.
  u32 previousButtons = BUTTONS;
  u32 currentButtons = BUTTONS;

  // Load initial application state
  enum gba_state state = START; 
  int cycles = 0;

  struct fishes player = {10, 110, FISH_WIDTH, FISH_HEIGHT, 2, 2};
  struct coralreef goal = {115, 95, CORAL_WIDTH, CORAL_HEIGHT};

  struct predator obstacles[5] = {
    {25, 10, 0, 0, 1},
    {25, 165, 0, 0, 1},
    {75, 100, 0, 0, 2},
    {105, 25, 0, 0, 2},
    {105, 180, 0, 0, 2}
  };

  int numObstacles = sizeof(obstacles) / sizeof(obstacles[0]);
  for (int i = 0; i < numObstacles; i++) {
    if (obstacles[i].type == 1) {
      obstacles[i].width = SHARK_WIDTH;
      obstacles[i].height = SHARK_HEIGHT;
    } else if (obstacles[i].type == 2) {
      obstacles[i].width = TURTLE_WIDTH;
      obstacles[i].height = TURTLE_HEIGHT;
    }
  }

  while (1) {
    currentButtons = BUTTONS; // Load the current state of the buttons

    /* TODO: */
    // Manipulate the state machine below as needed //
    // NOTE: Call waitForVBlank() before you draw

    switch (state) {
      case START:
        player.row = 10;
        player.col = 110;
        player.height = FISH_HEIGHT;
        player.width = FISH_HEIGHT;
        player.uvel = 2;
        player.hvel = 2;

        waitForVBlank();
        if (cycles == 0) {
          drawFullScreenImageDMA(underwater);
        }
        drawCenteredString(110, 120, 0, 0, "FISH FRENZY", 0xFFFF);
        drawCenteredString(130, 120, 0, 0, "PRESS START TO PLAY", 0xFFFF);

        if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
          state = PLAY;
          vBlankCounter = 0;
          cycles = 0;
          previousButtons = BUTTONS;
          break;
        }

        previousButtons = BUTTONS;
        cycles++;
        break;

      case PLAY:
        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
          state = START;
          cycles = 0;
          previousButtons = BUTTONS;
          break;
        }

        int prevrow = player.row;
        int prevcol = player.col;

        if (KEY_DOWN(BUTTON_UP, currentButtons)) {
          player.row -= player.uvel;
          if (player.row < 0) {
            player.row = 0;
          }
        }

        if (KEY_DOWN(BUTTON_DOWN, currentButtons)) {
          player.row += player.uvel;
          if (player.row > HEIGHT - player.height) {
            player.row = HEIGHT - player.height;
          }
        }

        if (KEY_DOWN(BUTTON_LEFT, currentButtons)) {
          player.col -= player.hvel;
          if (player.col < 0) {
            player.col = 0;
          }
        }

        if (KEY_DOWN(BUTTON_RIGHT, currentButtons)) {
          player.col += player.hvel;
          if (player.col > WIDTH - player.width) {
            player.col = WIDTH - player.width;
          }
        }

        if ((SCORE_COL <= player.col + player.width && SCORE_COL + 60 - 1 >= player.col) && (SCORE_ROW <= player.row + player.height && SCORE_ROW + 10 - 1 >= player.row)) {
          player.col = prevcol;
          player.row = prevrow;
        }

        int collided = 0;
        for (int i = 0; i < numObstacles; i++) {
          if ((obstacles[i].col + 1 <= player.col + player.width && obstacles[i].col + obstacles[i].width - 1 >= player.col)
          && (obstacles[i].row + 1 <= player.row + player.height && obstacles[i].row + obstacles[i].height - 1 >= player.row)) {
            // delay(10);
            state = LOSE;
            cycles = 0;
            previousButtons = BUTTONS;
            collided = 1;
            break;
          }
        }

        if ((goal.col + 1 <= player.col + player.width && goal.col + goal.width - 1 >= player.col)
          && (goal.row <= player.row + player.height && goal.row + goal.height - 1 >= player.row)) {
            // delay(10);
            state = WIN;
            cycles = 0;
            previousButtons = BUTTONS;
            collided = 1;
            break;
        }

        if (collided) {
          break;
        }

        char buffer[50];
        int time = vBlankCounter / 10;
        sprintf(buffer, "SCORE: %d", time);

        waitForVBlank();
        if (cycles == 0) {
          fillScreenDMA(BLACK);
          // drawFullScreenImageDMA(underwater);
          for (int i = 0; i < numObstacles; i++) {
            if (obstacles[i].type == 1) {
              drawImageDMA(obstacles[i].row, obstacles[i].col, obstacles[i].width, obstacles[i].height, shark);
            } else if (obstacles[i].type == 2) {
              drawImageDMA(obstacles[i].row, obstacles[i].col, obstacles[i].width, obstacles[i].height, turtle);
            }
          }
          drawImageDMA(115, 95, CORAL_WIDTH, CORAL_HEIGHT, coral);
        } else {
          undrawImageDMA(prevrow, prevcol, FISH_WIDTH, FISH_HEIGHT, blank);
          drawImageDMA(player.row, player.col, FISH_WIDTH, FISH_HEIGHT, fish);
          undrawImageDMA(10, 175, 80, 10, blank);
          drawString(10, 175, buffer, 0xFFFF);
        }

        cycles++;
        previousButtons = BUTTONS;
        break;

      case WIN:
        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
          state = START;
          cycles = 0;
          previousButtons = BUTTONS;
          break;
        }

        waitForVBlank();
        if (cycles == 0) {
          drawFullScreenImageDMA(wonscreen);
          int score = vBlankCounter / 10;
          sprintf(buffer, "FINAL SCORE: %d", score);
          drawCenteredString(40, 120, 0, 0, "YOU MADE IT TO SAFETY!", 0xFFFF);
          drawCenteredString(60, 120, 0, 0, buffer, 0xFFFF);
        }
        
        cycles++;
        break;

      case LOSE:
        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
          state = START;
          cycles = 0;
          previousButtons = BUTTONS;
          break;
        }
        waitForVBlank();
        if (cycles == 0) {
          drawFullScreenImageDMA(lostscreen);
        } else {
          drawCenteredString(50, 120, 0, 0, "YOU DIED!", 0xFFFF);
          drawCenteredString(70, 120, 0, 0, "END TO PLAY AGAIN", 0xFFFF);
        }
        
        cycles++;
        break;
    }

    previousButtons = currentButtons; // Store the current state of the buttons
  }

  UNUSED(previousButtons); // You can remove this once previousButtons is used

  return 0;
}
